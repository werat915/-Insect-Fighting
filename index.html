<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>昆蟲格鬥 LF2 - 完美比例版</title>
    <style>
        /* --- 1. 全螢幕基礎設定 --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #000; /* 黑邊 */
            color: white;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: "Microsoft JhengHei", sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- 2. 遊戲畫布 (由 JS 控制尺寸) --- */
        /* Canvas 會被 JS 賦予 style width/height，這裡只需確保它置中 */
        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            background: #222;
        }

        /* --- 3. UI 覆蓋層 (跟隨 Canvas 大小) --- */
        /* 這個容器會被 JS 動態調整大小，以完全重疊在 Canvas 上 */
        #game-ui-layer {
            position: absolute;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        #hud-top-bar {
            width: 100%;
            height: 15%;
            padding: 10px 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0));
            text-shadow: 1px 1px 2px black;
        }

        #p1-stats div, #level-info div { font-size: 16px; }
        .level-title { font-size: 20px !important; color: #ff9800; font-weight: bold; }
        
        #combo-container {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        #combo-count { font-size: 40px; font-weight: 900; font-style: italic; color: #ffeb3b; text-shadow: 0 0 5px #f44336; }
        #combo-label { font-size: 12px; letter-spacing: 2px; }

        /* --- 4. 觸控控制器 (貼齊螢幕邊緣) --- */
        /* 控制器不跟隨 4:3，而是貼齊手機真實螢幕邊緣，方便按壓 */
        #mobile-controls {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        /* 右側動作鍵區域 */
        #actions-zone {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 100px;
            pointer-events: auto;
        }

        .btn {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .btn:active { background: rgba(255, 200, 0, 0.6); border-color: #ffeb3b; transform: scale(0.95); }

        #btn-atk { bottom: 0; left: 0; width: 80px; height: 80px; background: rgba(255, 50, 50, 0.25); }
        #btn-jump { top: -20px; right: 0; width: 70px; height: 70px; background: rgba(50, 50, 255, 0.25); }

        /* 全向搖桿樣式 */
        #joystick-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }
        
        #joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            backdrop-filter: blur(2px);
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            pointer-events: none;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>
<body>

<!-- 這裡不設 ID，直接讓 p5.js 插入 canvas 到 body -->

<!-- UI 層：會透過 JS 動態調整大小以疊在 Canvas 上 -->
<div id="game-ui-layer">
    <div id="hud-top-bar">
        <div id="p1-stats"></div>
        <div id="level-info"></div>
    </div>
    <div id="combo-container" style="display: none;">
        <div id="combo-count">0</div>
        <div id="combo-label">HITS</div>
    </div>
</div>

<!-- 觸控控制器：始終全螢幕 -->
<div id="mobile-controls">
    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-knob"></div>
        </div>
    </div>
    <div id="actions-zone">
        <div id="btn-atk" class="btn">攻</div>
        <div id="btn-jump" class="btn">跳</div>
    </div>
</div>

<script>
/**
 * 昆蟲格鬥 LF2 - 完美比例版
 * 特色：JS 強制計算 4:3 顯示尺寸，絕不變形
 */

const LEVEL_CONFIG = {
    1: { ROACH: 3, BEE: 0, SPIDER: 0 },
    2: { ROACH: 5, BEE: 2, SPIDER: 0 },
    3: { ROACH: 7, BEE: 4, SPIDER: 0 },
    4: { ROACH: 9, BEE: 6, SPIDER: 0 },
    5: { ROACH: 3, BEE: 3, SPIDER: 1 }
};

let gameState = "MENU"; 
let currentStage = 1;
let spawnQueue = [];
let spawnTimer = 0;

let player;
let allies = [];
let enemies = [];
let projectiles = [];
let particles = [];
let items = [];
let cameraX = 0;
let gameWidth = 1800;

const KEYS = { W:87, A:65, S:83, D:68, J:74, K:75 };
const GRAVITY = 0.7;
let selectedCharType = "RHINO"; 

// 輸入狀態
const inputState = { moveX: 0, moveY: 0, J: false, K: false };

function setup() {
    // 內部解析度固定 800x600 (4:3)
    let cnv = createCanvas(800, 600);
    noSmooth();
    textFont("Microsoft JhengHei");
    textAlign(CENTER, CENTER);
    
    // 初始化控制器
    setupControls();
    
    // 初始化畫面大小
    windowResized();
}

// --- 關鍵：視窗縮放處理 ---
function windowResized() {
    let targetRatio = 4 / 3;
    let windowRatio = window.innerWidth / window.innerHeight;
    let newWidth, newHeight;

    if (windowRatio > targetRatio) {
        // 螢幕比較寬 -> 高度填滿，寬度依比例
        newHeight = window.innerHeight;
        newWidth = newHeight * targetRatio;
    } else {
        // 螢幕比較窄 -> 寬度填滿，高度依比例
        newWidth = window.innerWidth;
        newHeight = newWidth / targetRatio;
    }

    // 調整 Canvas 的 CSS 顯示大小 (不改變內部 pixel)
    let c = select('canvas');
    c.style('width', newWidth + 'px');
    c.style('height', newHeight + 'px');

    // 調整 UI 層的大小與 Canvas 一致
    let ui = document.getElementById('game-ui-layer');
    ui.style.width = newWidth + 'px';
    ui.style.height = newHeight + 'px';
}

// --- 控制器設置 ---
function setupControls() {
    const bindBtn = (id, key) => {
        let el = document.getElementById(id);
        el.addEventListener('touchstart', (e) => { e.preventDefault(); inputState[key] = true; el.style.backgroundColor = "rgba(255, 200, 0, 0.6)"; }, {passive:false});
        el.addEventListener('touchend', (e) => { e.preventDefault(); inputState[key] = false; el.style.backgroundColor = ""; }, {passive:false});
    };
    bindBtn('btn-atk', 'J');
    bindBtn('btn-jump', 'K');

    const joyContainer = document.getElementById('joystick-container');
    const joyKnob = document.getElementById('joystick-knob');
    let joyActive = false;
    let joyBaseX, joyBaseY;
    const maxRadius = 60;

    joyContainer.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joyActive = true;
        const rect = joyContainer.getBoundingClientRect();
        joyBaseX = rect.left + rect.width / 2;
        joyBaseY = rect.top + rect.height / 2;
        updateJoystick(e.touches[0]);
    }, {passive:false});

    joyContainer.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (joyActive) updateJoystick(e.touches[0]);
    }, {passive:false});

    const resetJoystick = () => {
        joyActive = false;
        inputState.moveX = 0; inputState.moveY = 0;
        joyKnob.style.transform = `translate(-50%, -50%)`;
    };

    joyContainer.addEventListener('touchend', (e) => { e.preventDefault(); resetJoystick(); }, {passive:false});
    joyContainer.addEventListener('touchcancel', (e) => { e.preventDefault(); resetJoystick(); }, {passive:false});

    function updateJoystick(touch) {
        let dx = touch.clientX - joyBaseX;
        let dy = touch.clientY - joyBaseY;
        let distance = Math.sqrt(dx*dx + dy*dy);
        let limitedDist = Math.min(distance, maxRadius);
        let angle = Math.atan2(dy, dx);
        let knobX = Math.cos(angle) * limitedDist;
        let knobY = Math.sin(angle) * limitedDist;
        joyKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
        inputState.moveX = knobX / maxRadius;
        inputState.moveY = knobY / maxRadius;
    }
}

function getMoveInput() {
    let x = inputState.moveX;
    let y = inputState.moveY;
    if (keyIsDown(KEYS.A)) x = -1;
    if (keyIsDown(KEYS.D)) x = 1;
    if (keyIsDown(KEYS.W)) y = -1;
    if (keyIsDown(KEYS.S)) y = 1;
    return { x, y };
}

function draw() {
    background(40);

    if (gameState === "MENU") {
        drawMenu();
        document.getElementById('game-ui-layer').style.display = 'none';
        document.getElementById('mobile-controls').style.display = 'none';
    } else {
        document.getElementById('game-ui-layer').style.display = 'flex';
        document.getElementById('mobile-controls').style.display = 'block';
        
        if (gameState === "PLAY") {
            updateGame();
            drawGameScene();
            updateHUD();
        } else if (gameState === "LEVEL_TRANSITION") {
            drawGameScene();
            drawTransition();
            updateHUD();
        } else if (gameState === "GAMEOVER" || gameState === "WIN") {
            drawGameScene();
            drawEndScreen();
        }
    }
}

function startGame(type) {
    selectedCharType = type;
    currentStage = 1;
    player = null; 
    startLevel(currentStage);
}

function startLevel(stage) {
    if (stage > 5) { gameState = "WIN"; return; }
    gameState = "PLAY";
    cameraX = 0;
    
    if (!player) {
        player = new Fighter(100, 300, selectedCharType, 1);
        player.isPlayer = true;
    } else {
        player.x = 100; player.z = 300; player.facing = 1;
        player.state = "IDLE"; player.vx = 0; player.vz = 0;
        player.status = null; 
        player.initStats(); 
    }

    allies = [player];
    enemies = [];
    projectiles = [];
    particles = [];
    items = [];
    prepareSpawnQueue(stage);
}

function prepareSpawnQueue(stage) {
    spawnQueue = [];
    let config = LEVEL_CONFIG[stage];
    for(let i=0; i<config.SPIDER; i++) spawnQueue.push("SPIDER");
    for(let i=0; i<config.BEE; i++) spawnQueue.push("BEE");
    for(let i=0; i<config.ROACH; i++) spawnQueue.push("ROACH");
    spawnQueue.sort((a, b) => (a === "SPIDER" ? 1 : -1));
}

function updateGame() {
    spawnTimer++;
    if (enemies.length < 5 && spawnQueue.length > 0 && spawnTimer > 60) {
        spawnTimer = 0;
        spawnEnemy(spawnQueue.pop());
    }
    if (spawnQueue.length === 0 && enemies.length === 0) {
        if (spawnTimer > 150) {
            if (currentStage === 5) gameState = "WIN";
            else { gameState = "LEVEL_TRANSITION"; spawnTimer = 0; }
        }
    }

    let allFighters = [...allies, ...enemies];
    for (let f of allFighters) {
        f.update();
        if (f.isPlayer) f.control();
        else f.ai([...allies]);
    }

    updateProjectiles();
    checkCombat(allies, enemies);
    checkCombat(enemies, allies);
    updateItems();
    cleanUpEntities();
    updateParticles();

    let targetCamX = player.x - width * 0.3;
    if (isNaN(targetCamX)) targetCamX = 0;
    targetCamX = constrain(targetCamX, 0, gameWidth - width);
    cameraX = lerp(cameraX, targetCamX, 0.1);
    if (isNaN(cameraX)) cameraX = 0;

    if (player.state === "DEAD" && player.stateTimer > 90) gameState = "GAMEOVER";
}

function spawnEnemy(type) {
    let x = cameraX + width + 50;
    let z = random(250, 450);
    let e = new Fighter(x, z, type, 2);
    if (type !== "SPIDER") { e.maxHp += (currentStage * 5); e.damage += currentStage; }
    enemies.push(e);
    if (type === "SPIDER") {
        particles.push(new TextParticle(width/2 + cameraX, 200, "⚠️ BOSS ⚠️", color(200, 0, 200), 40));
    }
}

// --- 戰鬥系統 ---

function checkCombat(attackers, defenders) {
    for (let atk of attackers) {
        if (atk.attackBoxActive && !atk.hasHit) {
            for (let def of defenders) {
                if (def.state !== "DEAD" && def.state !== "HURT_INVINCIBLE" && def.state !== "JUMP_AIR") {
                    if (checkHit(atk, def)) {
                        applyDamage(atk, def, atk.damage);
                        atk.hasHit = true;
                    }
                }
            }
        }
        if (atk.type === "SPIDER") {
            if (atk.state === "LANDING" && atk.stateTimer === 1) {
                for (let def of defenders) {
                    if (dist(atk.targetX, atk.targetZ, def.x, def.z) < 80 && abs(def.y) < 50) {
                        applyDamage(atk, def, atk.damage * 1.5);
                        createHitEffect(def.x, def.z - def.y);
                    }
                }
            }
        }
    }
}

function applyDamage(atk, def, dmg) {
    if (atk.isPlayer) { atk.combo++; atk.comboTimer = 120; }
    let finalDmg = dmg;
    if (atk.isPlayer && atk.type === "RHINO" && atk.combo % 5 === 0) {
        if (def.type === "SPIDER") finalDmg *= 3;
        else finalDmg = 9999;
        screenShake(5);
        particles.push(new TextParticle(def.x, def.z - def.y - 100, "CRITICAL!", color(255,50,0), 30));
    }
    def.takeDamage(finalDmg, atk.facing);
    createHitEffect(def.x, def.z - def.y - 40);
}

function checkHit(atk, def) {
    if (abs(atk.z - def.z) > 25) return false;
    let facing = (atk.facing === 1 && def.x > atk.x) || (atk.facing === -1 && def.x < atk.x);
    let xDist = abs(atk.x - def.x);
    let yDist = abs(atk.y - def.y);
    if (xDist < atk.attackRange && facing && yDist < 80) return true;
    return false;
}

function checkProjectileHit(p, def) {
    if (abs(p.z - def.z) > 25) return false;
    if (abs(p.x - def.x) < 25 && abs(p.y - def.y) < 80) return true;
    return false;
}

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.update();
        let targets = (p.team === 1) ? enemies : allies;
        for (let t of targets) {
            if (t.state !== "DEAD" && checkProjectileHit(p, t)) {
                t.takeDamage(p.damage, p.vx > 0 ? 1 : -1);
                createHitEffect(t.x, t.z - t.y - 30);
                p.life = 0; break; 
            }
        }
        if (p.life <= 0) projectiles.splice(i, 1);
    }
}

// --- 實體類別 ---

class Fighter {
    constructor(x, z, type, team) {
        this.x = x; this.z = z; this.y = 0;
        this.vx = 0; this.vz = 0; this.vy = 0;
        this.type = type; this.team = team;
        this.isPlayer = false; this.facing = 1;
        this.state = "IDLE"; this.stateTimer = 0; this.animFrame = 0;
        this.combo = 0; this.comboTimer = 0;
        this.width = 40; this.height = 60; this.scale = 1;
        this.initStats();
        this.targetX = 0; this.targetZ = 0;
        this.status = null; this.statusTimer = 0;
    }

    initStats() {
        if (this.type === "ROACH") {
            this.maxHp = 60; this.damage = 8; this.speed = 3.5; this.attackRange = 80;
        } else if (this.type === "BEE") {
            this.maxHp = 40; this.damage = 10; this.speed = 2.0; this.attackRange = 350;
            this.y = 50; 
        } else if (this.type === "SPIDER") {
            this.maxHp = 500; this.damage = 20; this.speed = 2.5; this.attackRange = 90;
            this.scale = 2.0;
        } else if (this.type === "STAG") {
            this.maxHp = 150; this.damage = 8; this.speed = 4.5; this.attackRange = 140;
        } else { // RHINO
            this.maxHp = 150; this.damage = 15; this.speed = 5; this.attackRange = 90;
        }
        this.hp = this.maxHp;
        this.originalSpeed = this.speed; 
    }

    update() {
        if (this.state === "DEAD") { this.stateTimer++; return; }
        if (this.status) {
            this.statusTimer--;
            if (this.statusTimer <= 0) { this.status = null; this.speed = this.originalSpeed || 5; }
        }
        if (isNaN(this.speed)) this.speed = this.originalSpeed || 5;
        if (this.combo > 0) {
            this.comboTimer--;
            if (this.comboTimer <= 0) this.combo = 0;
        }

        if (this.type === "SPIDER") this.updateSpiderLogic();
        else if (this.type === "BEE") this.updateBeeLogic();
        else this.updateGeneralLogic();

        this.stateTimer++;
        this.animFrame += 0.2;
        if (isNaN(this.x)) this.x = 0;
        if (isNaN(this.y)) this.y = 0;
        if (isNaN(this.z)) this.z = 300;
    }

    updateGeneralLogic() {
        if (this.status !== "FREEZE") { this.x += this.vx; this.z += this.vz; }
        this.z = constrain(this.z, 220, height - 20);
        if (this.y > 0 || this.vy !== 0) {
            this.y += this.vy; this.vy -= GRAVITY;
            if (this.y <= 0) { this.y = 0; this.vy = 0; if (this.state === "JUMP" || this.state === "HURT") this.state = "IDLE"; }
        }
        if (this.state === "ATTACK" && this.stateTimer > 25) { this.state = "IDLE"; this.attackBoxActive = false; }
        if (this.state === "HURT" && this.stateTimer > 20 && this.y === 0) this.state = "IDLE";
        if (this.state !== "WALK" && this.y === 0 && this.state !== "HURT") { this.vx *= 0.8; this.vz *= 0.8; }
        if (this.state === "ATTACK") this.attackBoxActive = (this.stateTimer >= 8 && this.stateTimer <= 18);
    }

    updateBeeLogic() {
        if (this.state !== "CHARGE" && this.state !== "ATTACK" && this.state !== "HURT") {
            this.y = 60 + sin(frameCount * 0.1) * 10; 
            this.x += this.vx; this.z += this.vz;
            this.z = constrain(this.z, 220, height - 20);
        }
        if (this.state === "CHARGE") {
            if (this.stateTimer > 120) {
                this.state = "ATTACK"; this.stateTimer = 0;
                let p = new Projectile(this.x, this.z, this.y - 15, this.facing, this.team);
                p.damage = this.damage;
                projectiles.push(p);
            }
        }
        if (this.state === "ATTACK" && this.stateTimer > 20) this.state = "IDLE";
        if (this.state === "HURT" && this.stateTimer > 20) this.state = "IDLE";
        if (this.state !== "WALK") { this.vx *= 0.9; this.vz *= 0.9; }
    }

    updateSpiderLogic() {
        if (this.state === "JUMP_START") { this.vy = 20; this.state = "JUMP_AIR"; this.stateTimer = 0; }
        else if (this.state === "JUMP_AIR") {
            this.y += this.vy;
            if (this.stateTimer > 180) {
                this.x = this.targetX; this.z = this.targetZ; this.y = 400; this.vy = -30;
                this.state = "LANDING"; this.stateTimer = 0;
            }
        }
        else if (this.state === "LANDING") {
            this.y += this.vy;
            if (this.y <= 0) {
                this.y = 0; this.vy = 0; this.stateTimer = 0; screenShake(10);
                if (frameCount % 60 === 0) this.state = "IDLE"; 
            }
            if (this.y === 0 && this.stateTimer > 30) this.state = "IDLE";
        }
        else this.updateGeneralLogic();
    }

    control() {
        if (this.state === "HURT" || this.state === "DEAD" || this.state === "ATTACK") return;
        
        let moveData = getMoveInput(); 
        let mx = moveData.x;
        let my = moveData.y;
        
        let moving = false;

        if (Math.abs(mx) > 0.1) {
            this.vx = mx * this.speed;
            this.facing = mx > 0 ? 1 : -1;
            moving = true;
        }

        if (Math.abs(my) > 0.1) {
            this.vz = my * this.speed * 0.7; 
            moving = true;
        }

        let jumpKey = keyIsDown(KEYS.K) || inputState.K;
        let atkKey = keyIsDown(KEYS.J) || inputState.J;

        if (jumpKey && this.y === 0) { this.vy = 12; this.state="JUMP"; }
        if (atkKey && this.state!=="JUMP") {
            this.state="ATTACK"; this.stateTimer=0; this.hasHit=false;
            this.vx=0; this.vz=0; return;
        }
        
        if (this.y===0 && this.state!=="ATTACK") this.state = moving ? "WALK" : "IDLE";
    }

    ai(targets) {
        if (this.state === "HURT" || this.state === "DEAD" || this.state === "ATTACK") return;
        if (this.type === "SPIDER" && (["JUMP_AIR","LANDING"].includes(this.state))) return;
        if (this.type === "BEE" && this.state === "CHARGE") return;

        let t = this.findTarget(targets);
        if (!t) { this.state = "IDLE"; return; }

        let dx = t.x - this.x; let dz = t.z - this.z;
        let distTo = sqrt(dx*dx + dz*dz);
        this.facing = dx > 0 ? 1 : -1;

        if (this.type === "BEE") {
            if (distTo < 350) {
                this.vx = 0; this.vz = 0; this.state = "IDLE";
                if (random() < 0.02) { this.state = "CHARGE"; this.stateTimer = 0; this.targetX = t.x; }
            } else {
                this.state = "WALK"; this.vx = (dx>0?1:-1) * this.speed; this.vz = (dz>0?1:-1) * this.speed * 0.5;
            }
            return;
        }
        if (this.type === "SPIDER") {
            if (distTo < 100) {
                this.vx = 0; this.vz = 0; this.state = "IDLE";
                if (random() < 0.05) { this.state="ATTACK"; this.stateTimer=0; this.hasHit=false; }
            } else {
                if (random() < 0.02) { this.state = "JUMP_START"; this.targetX = t.x; this.targetZ = t.z; }
                else { this.state = "WALK"; this.vx = (dx>0?1:-1) * this.speed; this.vz = (dz>0?1:-1) * this.speed * 0.5; }
            }
            return;
        }
        if (abs(dx) < this.attackRange * 0.8 && abs(dz) < 20) {
            this.vx=0; this.vz=0; this.state="IDLE";
            if(random()<0.05) { this.state="ATTACK"; this.stateTimer=0; this.hasHit=false; }
        } else {
            this.state="WALK";
            if (abs(dx) > this.attackRange * 0.7) this.vx = (dx>0?1:-1) * this.speed; else this.vx=0;
            if (abs(dz) > 10) this.vz = (dz>0?1:-1) * this.speed * 0.5; else this.vz=0;
        }
    }

    findTarget(targets) {
        let closest = null, minD = 9999;
        for (let t of targets) {
            if (t.state === "DEAD") continue;
            let d = dist(this.x, this.z, t.x, t.z);
            if (d < minD) { minD=d; closest=t; }
        }
        return closest;
    }

    takeDamage(amt, dir) {
        if(this.state==="DEAD") return;
        this.hp -= amt;
        this.state = "HURT"; this.stateTimer = 0;
        this.vx = dir * 5; this.vy = 4;
        this.status = null; this.speed = this.originalSpeed || 5;
        particles.push(new TextParticle(this.x, this.z-this.y-80, "-"+amt, color(255,50,50)));
        if (this.hp <= 0) {
            this.hp = 0; this.state="DEAD"; this.vx=dir*3; this.vy=6;
            if (this.team===2 && !this.dropped) {
                if(random()<0.2) items.push({x:this.x, z:this.z, val:10});
                this.dropped=true;
            }
        }
    }

    draw() {
        if (isNaN(this.x) || isNaN(this.y) || isNaN(this.z)) return;
        push();
        translate(this.x, this.z - this.y);
        
        if (this.type === "BEE" && this.state === "CHARGE") {
            stroke(255, 0, 0, 150); strokeWeight(2);
            line(0, 0, 300 * this.facing, 0); noStroke();
        }
        scale(this.facing * this.scale, this.scale);

        if (this.state !== "JUMP_AIR") { noStroke(); fill(0, 80); ellipse(0, this.y, 50, 15); }
        if (this.state === "HURT" && frameCount%4<2) tint(255, 0, 0);
        if (this.status === "SLOW") tint(150, 150, 150);
        if (this.status === "FREEZE") tint(0, 255, 255);

        if (this.type === "RHINO") this.drawRhino();
        else if (this.type === "STAG") this.drawStag();
        else if (this.type === "ROACH") this.drawRoach();
        else if (this.type === "BEE") this.drawBee();
        else if (this.type === "SPIDER") this.drawSpider();

        noTint();
        if (!this.isPlayer && this.state !== "DEAD") {
            fill(0); rect(-20, -100, 40, 6);
            fill(this.team===1?'cyan':'red'); rect(-20, -100, 40*(this.hp/this.maxHp), 6);
        }
        pop();
    }

    drawBee(){let a=sin(frameCount*0.8)*5;stroke(0);strokeWeight(1);fill(255,255,255,200);let wf=sin(frameCount*2)*20;ellipse(-5,-35-wf,30,10);ellipse(5,-35-wf,30,10);noStroke();fill(255,220,0);ellipse(0,-20,30,40);fill(0);rect(-12,-30,24,5);rect(-14,-20,28,5);rect(-10,-10,20,5);fill(50);triangle(0,0,-3,5,3,5);fill(255);ellipse(5,-35,10,10);fill(0);ellipse(7,-35,3,3);}
    drawSpider(){if(this.state==="JUMP_AIR")return;let a=(this.state==="WALK")?sin(this.animFrame)*10:0;stroke(20);strokeWeight(3);for(let i=0;i<4;i++){let o=(i%2==0)?1:-1;line(0,-20,-30+a*o,-10+i*5);line(-30+a*o,-10+i*5,-40,0);line(0,-20,30-a*o,-10+i*5);line(30-a*o,-10+i*5,40,0);}noStroke();fill(40,0,40);ellipse(-15,-25,50,40);fill(255,0,0);triangle(-20,-25,-10,-25,-15,-15);triangle(-20,-25,-10,-25,-15,-35);fill(20);ellipse(10,-25,30,25);fill(255,0,0);ellipse(15,-30,4,4);ellipse(18,-28,4,4);ellipse(15,-22,4,4);}
    drawRhino(){ let att=(this.state==="ATTACK")?(this.stateTimer<10?-5:35):0; let anim=sin(this.animFrame)*15; stroke(20);strokeWeight(2);fill(60,30,10);this.drawLeg(-10,-10,anim);this.drawLeg(10,-10,-anim);ellipse(0,-45,50,65);fill(50,20,0);ellipse(0,-65,45,45);push();translate(5,-75);rotate(0.3);fill(40,10,0);ellipse(0,0,35,35);beginShape();vertex(10,-10);vertex(45+att,-40);vertex(10,-5);endShape(CLOSE);pop();this.drawLeg(10,-55,att+anim);}
    drawStag(){ 
        let jaw=(this.state==="ATTACK"&&this.stateTimer<20)?40:10; 
        let anim=sin(this.animFrame)*15; 
        stroke(20);strokeWeight(2);fill(30);
        this.drawLeg(-12,-10,anim);this.drawLeg(12,-10,-anim);
        rect(-22,-65,44,55,12);fill(10);ellipse(0,-70,40,35);
        push();
        translate(10,-75);fill(60,10,10);
            push(); rotate(radians(-jaw));arc(20,0,60,10,PI,0); pop();
            push(); translate(0,10);rotate(radians(jaw));arc(20,0,60,10,0,PI); pop();
        pop();
        this.drawLeg(10,-60,anim);
    }
    drawRoach(){ let anim=sin(this.animFrame*2.5)*20; stroke(40,20,0);noFill();for(let i=0;i<3;i++){let o=(i%2===0)?1:-1;line(-5,-10-i*8,-20+anim*o,-i*8);line(5,-10-i*8,20-anim*o,-i*8);}noStroke();fill(90,50,10);ellipse(0,-25,45,25);fill(110,60,20);ellipse(-5,-28,55,20);stroke(100,50,0);noFill();bezier(15,-25,30,-40,40+anim,-30,50,-50);}
    drawLeg(x,y,r){push();translate(x,y);rotate(radians(r));line(0,0,0,25);pop();}
}

class Projectile { constructor(x, z, y, facing, team) { this.x=x;this.z=z;this.y=y;this.facing=facing;this.team=team;this.vx=facing*10;this.life=80;this.damage=10;this.isStagSpecial=false;} update(){this.x+=this.vx;this.life--;}}
class Particle { constructor(x, y) { this.x=x;this.y=y;this.life=255;} update(){this.life-=10;}}
class TextParticle extends Particle { 
    constructor(x,y,t,c,s){super(x,y);this.t=t;this.c=c;this.s=s||20;this.vy=-2;} 
    update(){this.y+=this.vy;this.life-=3;} 
    draw(){
        textAlign(CENTER);textSize(this.s);stroke(0,this.life);strokeWeight(3);
        let r=255,g=255,b=255;
        if(this.c && this.c.levels) { r=this.c.levels[0]; g=this.c.levels[1]; b=this.c.levels[2]; }
        fill(r,g,b,this.life);
        text(this.t,this.x,this.y);
    }
}
class HitParticle extends Particle { constructor(x,y){super(x,y);this.vx=random(-3,3);this.vy=random(-3,3);this.sz=random(10,30);} update(){super.update();this.x+=this.vx;this.y+=this.vy;this.sz*=0.9;} draw(){noStroke();fill(255,200,50,this.life);ellipse(this.x,this.y,this.sz);}}

function updateParticles(){for(let i=particles.length-1;i>=0;i--){particles[i].update();if(particles[i].draw)particles[i].draw();if(particles[i].life<=0)particles.splice(i,1);}}
function createHitEffect(x, y){for(let i=0;i<5;i++)particles.push(new HitParticle(x, y));}
function screenShake(amt){cameraX+=random(-amt,amt);}
function updateItems(){for(let i=items.length-1;i>=0;i--){let it=items[i];push();translate(it.x-cameraX,it.z);fill(0,255,0);noStroke();translate(0,-20+sin(frameCount*0.1)*5);beginShape();vertex(0,0);bezierVertex(-10,-10,-20,-5,0,15);bezierVertex(20,-5,10,-10,0,0);endShape();pop();if(dist(player.x,player.z,it.x,it.z)<40){player.hp=min(player.hp+it.val,player.maxHp);particles.push(new TextParticle(player.x,player.z-player.y-60,"+HP",color(0,255,0)));items.splice(i,1);}}}
function cleanUpEntities(){for(let i=enemies.length-1;i>=0;i--){if(enemies[i].state==="DEAD"&&enemies[i].stateTimer>120)enemies.splice(i,1);}for(let i=allies.length-1;i>=0;i--){if(allies[i].state==="DEAD"&&allies[i].stateTimer>120&&!allies[i].isPlayer)allies.splice(i,1);}}

function drawGameScene(){
    push();
    translate(-cameraX, 0);
    drawBackground();
    for(let e of enemies){
        if(e.type==="SPIDER" && e.state==="JUMP_AIR"){
            fill(255,0,0,100);noStroke();ellipse(e.targetX,e.targetZ,100+sin(frameCount*0.5)*20,100+sin(frameCount*0.5)*20);
        }
    }
    let renderList=[...allies,...enemies];
    renderList.sort((a,b)=>a.z-b.z);
    for(let e of renderList)e.draw();
    for(let p of projectiles){fill(255,255,0);noStroke();ellipse(p.x,p.z-p.y,10,10);}
    for(let p of particles)if(p.draw)p.draw();
    pop();
}

function updateHUD(){
    let hpPct=Math.max(0,player.hp/player.maxHp*100);
    let hpColor=hpPct>50?'#4caf50':(hpPct>20?'#ffeb3b':'#f44336');
    document.getElementById('p1-stats').innerHTML=`<div style="font-size:20px; font-weight:bold; color:white; letter-spacing:1px;">P1: ${selectedCharType}</div><div style="width:300px; height:20px; background:rgba(0,0,0,0.6); border:2px solid #fff; border-radius:4px;"><div style="width:${hpPct}%; height:100%; background:${hpColor}; transition:width 0.2s;"></div></div>`;
    document.getElementById('level-info').innerHTML=`<div class="level-title">STAGE ${currentStage}</div><div class="enemy-count">ENEMIES: ${enemies.length+spawnQueue.length}</div>`;
    let comboEl=document.getElementById('combo-container');
    if(player.combo>1){
        comboEl.style.display='block';
        document.getElementById('combo-count').innerText=player.combo;
        let scale=1+(player.combo%5===0?0.3:0);
        comboEl.style.transform=`translateX(-50%) scale(${scale})`;
        document.getElementById('combo-count').style.color=(player.combo%5===0)?'#ff5722':'#ffeb3b';
    }else{
        comboEl.style.display='none';
    }
}

function drawBackground(){noStroke();fill(30);rect(0,200,gameWidth,height-200);stroke(50);strokeWeight(1);for(let x=0;x<=gameWidth;x+=100)line(x,200,x-200,height);line(0,200,gameWidth,200);fill(20);noStroke();rect(0,0,gameWidth,200);fill(40);for(let i=0;i<gameWidth;i+=400)rect(i,20,40,180);fill(60);textSize(150);textAlign(CENTER,CENTER);text("STAGE "+currentStage,gameWidth/2,100);}
function drawTransition(){fill(0,150);rect(0,0,width,height);fill(255,255,0);textSize(50);text("STAGE CLEAR",width/2,height/2);spawnTimer++;if(spawnTimer>120){currentStage++;startLevel(currentStage);}}
function drawEndScreen(){fill(0,180);rect(0,0,width,height);if(gameState==="WIN"){fill(255,255,0);textSize(60);text("GAME CLEAR!",width/2,height/2-20);}else{fill(255,50,50);textSize(60);text("YOU DIED",width/2,height/2-20);}textSize(18);fill(150);text("點擊重試",width/2,height/2+100);}
function drawMenu(){background(20);fill(255);textSize(50);text("昆蟲格鬥 - 蜘蛛女王",width/2,100);textSize(18);fill(150);text("WASD移動 J攻擊 K跳躍",width/2,140);drawCard(250,320,"獨角仙","RHINO",color(100,50,0));drawCard(550,320,"鍬形蟲","STAG",color(50));}
function drawCard(x,y,name,type,c){let h=dist(mouseX,mouseY,x,y)<80;stroke(h?'#ffc107':'#666');strokeWeight(h?3:1);cursor(h?HAND:ARROW);fill(c);rect(x-75,y-100,150,200,10);noStroke();fill(255);textSize(24);text(name,x,y+60);}
function mousePressed(){if(gameState==="MENU"){if(dist(mouseX,mouseY,250,320)<80)startGame("RHINO");if(dist(mouseX,mouseY,550,320)<80)startGame("STAG");}else if(gameState==="GAMEOVER"||gameState==="WIN")gameState="MENU";}
function drawKeyVisuals(){}
</script>
</body>
</html>